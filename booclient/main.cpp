/*********************************************************************
 * Name:      	main.cpp
 * Purpose:   	Implements simple wxWidgets application with GUI
 * 				created using wxFormBuilder.
 * Author:
 * Created:
 * Copyright:
 * License:   	wxWidgets license (www.wxwidgets.org)
 *
 * Notes:		Note that all GUI creation code is implemented in
 * 				gui.cpp source file which is generated by wxFormBuilder.
 *********************************************************************/

#include "main.h"
#include "misc.h"

#include <string>
#include <sstream>
#include <algorithm>
#include <assert.h>
#include <wx/textdlg.h>

const int NLINE_INCREMENT = 10;

const int COLUMN_NAME = 0;
const int COLUMN_TITLE = 1;
const int COLUMN_PERIOD = 2;

MainFrame::MainFrame(wxWindow *parent):
 frmMain(parent),
 repo(nullptr),
 m_profile(nullptr),
 m_doctor(nullptr),
 m_rule(nullptr),
 chart()
{
  // Not working somehow
  // TODO: Icon for Linux
  //SetIcon(wxICON("icon"));
  bmpWeek->SetBitmap(chart.get());
  Layout();
}

MainFrame::~MainFrame() {
  saveDoctor();
}

std::shared_ptr<data::Repository> MainFrame::getRepository(void) {
  return repo;
}

void MainFrame::setRepository(std::shared_ptr<data::Repository> value) {
  repo = value;
}

void MainFrame::OnCloseFrame(wxCloseEvent& event) {
  Destroy();
}

void MainFrame::OnExitClick(wxCommandEvent& event) {
	Destroy();
}

void MainFrame::ProfileSelected (wxCommandEvent& event) {
  // Profile selected: set current profile, load doctors list
  m_profile = static_cast<Profile*>(event.GetClientData());
  loadDoctors(m_profile);
}

void MainFrame::DoctorSelected (wxCommandEvent& event) {
  int index = event.GetSelection();

  saveDoctor();

  // Since current record may have been removed by saveDoctor:
  if (index >= (int) lbxDoctors->GetCount()) --index;
  Doctor *d = nullptr;
  if (index >= 0) {
    d = static_cast<Doctor*>(lbxDoctors->GetClientData(index));
    lbxDoctors->Select(index);
  }

  loadDoctor(d);
}

void MainFrame::RuleItemSelected(wxListEvent& event) {
  saveRule();
  const wxListItem &item = event.GetItem();
  Rule *rule = reinterpret_cast<Rule*>(item.GetData());
  loadRule(rule);
}

void MainFrame::WeekdayChanged (wxCommandEvent& event) {
  chWeek->Enable(chWeekDay->GetSelection() != 0);
}

void MainFrame::OnDeptAdd( wxCommandEvent& event ) {
  // Add department (profile)

  // Get title from user
  wxString title = wxGetTextFromUser(_("Add Profile"),
    _("Profile title"),
    wxEmptyString,
    this);
  if (title.empty()) return;

  assert(repo.get());

  // New profile
  Profile *profile = new Profile(0, std::string(title.mb_str(wxConvUTF8)));
  profile->setNumber(repo->getLastProfileNumber() + NLINE_INCREMENT);
  profile->setActive(true);

  // Store to the database
  if (repo->saveProfile(profile)) {
    // Add to the profiles list and select
    int i = chProfile->Append(title, profile);
    m_profile = profile;
    chProfile->Select(i);
    loadDoctors(m_profile);
  } else {
    delete profile;
  }
}

void MainFrame::OnDeptRemove( wxCommandEvent& event ) {
  if (!m_profile) return;

  long index = findItem(chProfile, m_profile);
  if (index == wxNOT_FOUND) return;
  assert(index == chProfile->GetSelection());

  if (m_profile->isActive()) {
    if (wxMessageBox(_("Do you really wish to remove profile ") + chProfile->GetString(index) + wxT("?"),
      _("Remove Profile"),
      wxYES_NO | wxNO_DEFAULT | wxICON_QUESTION) != wxYES) return;
  } else {
    if (wxMessageBox(_("Do you wish to restore profile ") + chProfile->GetString(index) + wxT("?"),
      _("Restore Profile"),
      wxYES_NO | wxNO_DEFAULT | wxICON_QUESTION) != wxYES) return;
  }

  // Set inactive and store to the database
  m_profile->setActive(!m_profile->isActive());

  if (!repo->saveProfile(m_profile)) return;

  if (cbxOnlyActive->GetValue()) {
    // Update profiles list
    loadProfiles();
  }
}

void MainFrame::OnDeptRename(wxCommandEvent& event) {
  // Rename profile
  if (!m_profile) return;

  long index = findItem(chProfile, m_profile);
  if (index == wxNOT_FOUND) return;
  assert(index == chProfile->GetSelection());

  wxString oldValue = chProfile->GetString(index);
  wxString title = wxGetTextFromUser(_("New name"),
    _("Rename Profile"),
    oldValue,
    this);

  if (title == oldValue || title.empty()) return;

  // Store renamed value to the database, update controls
  m_profile->setTitle(std::string(title.mb_str(wxConvUTF8)));
  if (repo->saveProfile(m_profile)) {
    chProfile->SetString(index, title);
  }
}

void MainFrame::OnDoctorAdd( wxCommandEvent& event ) {
  if (!m_profile) return;

  wxString title = wxGetTextFromUser(_("Doctor title"),
    _("Add Doctor"),
    wxEmptyString,
    this);

  if (title.empty()) return;

  // Create doctor
  Doctor *doc = new Doctor(0, std::string(title.mb_str(wxConvUTF8)));
  doc->setActive(true);
  doc->setProfile(m_profile->getId());

  // Store to the database
  if (repo->saveDoctor(doc)) {
    // Update controls
    int index = lbxDoctors->Append(title, doc);
    lbxDoctors->Select(index);
    saveDoctor();
    loadDoctor(doc);
  } else {
    delete doc;
  }
}

void MainFrame::OnRuleAdd( wxCommandEvent& event ) {
  if (!m_doctor) return;

  wxString name = wxGetTextFromUser(_("Rule name"),
    _("Add Rule"),
    wxEmptyString,
    this);

  if (name.empty()) {
    wxMessageBox(_("Rule's name shouldn't be empty!"), _("Rule Name Empty"));
    return;
  }

  Rule *rule = new Rule(0, m_doctor->getId(), 0, std::string(name.mb_str(wxConvUTF8)));

  int n = NLINE_INCREMENT;
  auto m = std::max_element (rules.begin(), rules.end(), [] (const Rule *l, const Rule *r) { return l->getNumber() < r->getNumber(); });
  if (m != rules.end()) n += (*m)->getNumber();

  // To make the rule dirty
  rule->setNumber(n);
  if (repo->saveRule(rule)) {
    rules.push_back(rule);

    long index = lRules->InsertItem(rules.size(), name);
    lRules->SetItemPtrData(index, reinterpret_cast<wxUIntPtr>(rule));
    lRules->SetItem(index, 1, wxT("?"));
    lRules->SetItem(index, 2, wxT("-"));
    lRules->SetItemState(index, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);
  } else {
    delete rule;
  }
}

void MainFrame::OnRuleRemove(wxCommandEvent& event) {
  if (!m_rule) return;

  long index = lRules->FindItem(-1, reinterpret_cast<wxUIntPtr>(m_rule));
  assert (index != wxNOT_FOUND);

#ifdef DEBUG
  std::vector<Rule*>::const_iterator it = std::find(rules.begin(), rules.end(), m_rule);
  assert(index == it - rules.begin());
#endif

  if (wxMessageBox(_("Do you really wish to remove rule ") + lRules->GetItemText(index, 0) + wxT("?"),
    _("Remove Rule"),
    wxYES_NO | wxNO_DEFAULT | wxICON_QUESTION) != wxYES) return;

  if (!repo->deleteRule(m_rule)) return;

  m_rule = nullptr;
  rules[index] = nullptr;
  lRules->DeleteItem(index);

  std::copy(rules.begin() + index + 1, rules.end(), rules.begin() + index);
  rules.pop_back();

  updateImage();
}

bool MainFrame::load(void) {
  return loadProfiles();
}

bool MainFrame::loadProfiles(void) {
  // Clear controls
  m_profile = nullptr;
  clearItems<Profile>(chProfile);
  assert(repo.get());

  // Load from the database and put to the choice box
  std::vector<Profile*> profiles = repo->loadProfiles(cbxOnlyActive->GetValue());
  for (Profile *profile : profiles) {
    chProfile->Append(wxString(profile->getTitle().c_str(), wxConvUTF8), (void*)profile);
  }

  // Select first
  if (!profiles.empty()) {
    chProfile->SetSelection(0);
    m_profile = profiles.front();
  } else {
    chProfile->SetSelection(wxNOT_FOUND);
  }

  // Load doctors for the selected profile
  return loadDoctors(m_profile);
}

bool MainFrame::loadDoctors(const Profile *profile) {
  // Save current doctor
  saveDoctor();

  // Clear doctor's controls
  m_doctor = nullptr;
  clearItems<Doctor>(lbxDoctors);

  if (!profile)
    return loadDoctor(nullptr);

  assert(repo.get());

  // Load doctors from the database, put onto the listbox
  std::vector<Doctor*> ds = repo->loadDoctors(profile, cbxOnlyActive->GetValue());
  for (Doctor *doctor : ds) {
    lbxDoctors->Append(wxString(doctor->getName().c_str(), wxConvUTF8), (void*)doctor);
  }

  // Select first doctor
  Doctor *doctor = nullptr;
  if (!ds.empty()) {
    lbxDoctors->Select(0);
    doctor = ds.front();
  } else {
    lbxDoctors->Select(wxNOT_FOUND);
  }

  return loadDoctor(doctor);
}

bool MainFrame::loadDoctor(Doctor *doctor) {
  if (doctor) {
    // Show doctor's info on the controls
    edTitle->SetValue(wxString(doctor->getName().c_str(), wxConvUTF8));
    edName->SetValue(wxString(doctor->getFullName().c_str(), wxConvUTF8));
    edStudy->SetValue(wxString(doctor->getStudy().c_str(), wxConvUTF8));
    edPosition->SetValue(wxString(doctor->getDuty().c_str(), wxConvUTF8));
    edInstitute->SetValue(wxString(doctor->getInstitute().c_str(), wxConvUTF8));
    edCertificate->SetValue(wxString(doctor->getCertificate().c_str(), wxConvUTF8));
    edCategory->SetValue(wxString(doctor->getCategory().c_str(), wxConvUTF8));
    cbxActive->SetValue(doctor->isActive());
  } else {
    // Clear controls if no doctors selected
    edTitle->Clear();
    edName->Clear();
    edStudy->Clear();
    edPosition->Clear();
    edInstitute->Clear();
    edCertificate->Clear();
    edCategory->Clear();
    cbxActive->SetValue(false);
  }
  m_doctor = doctor;
  return loadRules(doctor);
}

bool MainFrame::loadRules(const Doctor *doctor) {
  saveRule();
  m_rule = nullptr;

  lRules->DeleteAllItems();
  for (Rule* rule : rules) delete rule;
  rules.clear();

  rules = repo->loadRules(m_doctor);
  int j = rules.size();

  {
    Freezer freezer(lRules);
    for (int i = 0; i < j; ++i) {
      Rule *rule = rules[i];
      long index = lRules->InsertItem(i, wxString(rule->getName().c_str(), wxConvUTF8));
      lRules->SetItemPtrData(index, reinterpret_cast<wxUIntPtr>(rule));
      lRules->SetItem(index, COLUMN_TITLE, wxString(rule->getTitle().c_str(), wxConvUTF8));
      lRules->SetItem(index, COLUMN_PERIOD, wxString(rule->showPeriod().c_str(), wxConvUTF8));
    }
    lRules->SetColumnWidth(0, wxLIST_AUTOSIZE);
    lRules->SetColumnWidth(1, wxLIST_AUTOSIZE);
  }

  updateImage();

  if (j > 0) {
    lRules->SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);
    return true;
  } else {
    return loadRule(nullptr);
  }
}

bool MainFrame::loadRule(Rule* rule) {
  if (rule) {
    edRuleName->SetValue(wxString(rule->getName().c_str(), wxConvUTF8));
    edRuleTitle->SetValue(wxString(rule->getTitle().c_str(), wxConvUTF8));
    if (rule->getFrom().isValid()) {
      cbxFrom->SetValue(true);
      dpFrom->Enable(true);
      
      // Bug in wxWidgets 3.1:
      // wxDatePickerCtrl considers it must show local date-time,
      // but getter/setter takes wxDateTime in UTC.
      // So one must convert wxDateTime to UTC before SetValue() and
      // from UTC after GetValue().
      wxDateTime d(rule->getFrom().asUnixTime());
      d.MakeUTC();
      dpFrom->SetValue(d);
    } else {
      cbxFrom->SetValue(false);
      dpFrom->Enable(false);
    }

    if (rule->getTill().isValid()) {
      cbxTill->SetValue(true);
      dpTill->Enable(true);
      wxDateTime d(rule->getTill().asUnixTime());
      d.MakeUTC();
      dpTill->SetValue(d);
    } else {
      cbxTill->SetValue(false);
      dpTill->Enable(false);
    }

    chParity->Select(rule->getParity());
    chWeekDay->Select(rule->getWeekday());
    if (rule->getWeekday()) {
      chWeek->Enable(true);
      chWeek->Select(rule->getWeek());
    } else {
      chWeek->Enable(false);
    }
  } else {
    edRuleTitle->Clear();

    cbxFrom->SetValue(false);
    dpFrom->Enable(false);

    cbxTill->SetValue(false);
    dpTill->Enable(false);

    chWeek->Enable(false);
  }
  m_rule = rule;
  return true;
}

bool MainFrame::saveRule(void) {
  if (!m_rule) return true;

  m_rule->setName(std::string(edRuleName->GetValue().mb_str(wxConvUTF8)));
  m_rule->setTitle(std::string(edRuleTitle->GetValue().mb_str(wxConvUTF8)));

  if (cbxFrom->GetValue()) {
    DateTime newDate(dpFrom->GetValue().MakeFromUTC().GetTicks());
    m_rule->setFrom(newDate);
  } else {
    m_rule->setFrom(DateTime());
  }

  if (cbxTill->GetValue()) {
    DateTime newDate(dpTill->GetValue().MakeFromUTC().GetTicks());
    m_rule->setTill(newDate);
  } else {
    m_rule->setTill(DateTime());
  }

  int index = chParity->GetSelection();
  if (index == wxNOT_FOUND) index = 0;
  m_rule->setParity(index);

  index = chWeekDay->GetSelection();
  if (index == wxNOT_FOUND) index = 0;
  m_rule->setWeekday(index);

  if (index) {
    index = chWeek->GetSelection();
    if (index == wxNOT_FOUND) index = 0;
    m_rule->setWeek(index);
  } else {
    m_rule->setWeek(0);
  }

  if (m_rule->isDirty()) {
    std::vector<Rule*>::const_iterator it = std::find(rules.begin(), rules.end(), m_rule);
    if (it != rules.end()) {
      index = it - rules.begin();
      lRules->SetItem(index, COLUMN_NAME, edRuleName->GetValue());
      lRules->SetItem(index, COLUMN_TITLE, edRuleTitle->GetValue());
      lRules->SetItem(index, COLUMN_PERIOD, wxString(m_rule->showPeriod().c_str(), wxConvUTF8));
    }
    updateImage();
  }

  return repo->saveRule(m_rule);
}

bool MainFrame::saveDoctor(void) {
  bool delDoctor = false;

  if (m_doctor) {
    // Put the doctor's model in accordanse to the controls
    long index = findItem(lbxDoctors, m_doctor);
    
    // Try to prevent timetable from accidentally erased name or study:
    wxString name = edTitle->GetValue();
    if (!name.empty())
      m_doctor->setName(std::string(name.mb_str(wxConvUTF8)));

    name = edStudy->GetValue();
    if (!name.empty())
      m_doctor->setStudy(std::string(name.mb_str(wxConvUTF8)));
      
    m_doctor->setFullName(std::string(edName->GetValue().mb_str(wxConvUTF8)));
    m_doctor->setDuty(std::string(edPosition->GetValue().mb_str(wxConvUTF8)));
    m_doctor->setInstitute(std::string(edInstitute->GetValue().mb_str(wxConvUTF8)));
    m_doctor->setCertificate(std::string(edCertificate->GetValue().mb_str(wxConvUTF8)));
    m_doctor->setCategory(std::string(edCategory->GetValue().mb_str(wxConvUTF8)));
    m_doctor->setActive(cbxActive->GetValue());

    if (!m_doctor->isActive() && cbxOnlyActive->GetValue() && index != wxNOT_FOUND) {
      // Remove doctor from the listbox when not active
      lbxDoctors->Delete(index);
      delDoctor = true;
    } else {
      // Update doctor timetable's title on the listbox
      if (m_doctor->isDirty() && index != wxNOT_FOUND) {
        lbxDoctors->SetString(index, wxString(m_doctor->getName().c_str(), wxConvUTF8));
      }
    }
  }

  bool result = repo->saveDoctor(m_doctor) && saveRule();

  if (delDoctor) {
    delete m_doctor;
    loadDoctor(nullptr);
  }

  return result;
}

void MainFrame::OnlyActiveClicked(wxCommandEvent& event) {
  loadProfiles();
}

void MainFrame::RuleMove(wxCommandEvent& event) {
  if (!m_rule) return;

  long index = lRules->GetNextItem (-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
  if (index == wxNOT_FOUND) return;

  // Item's index increased if btnRuleDown clicked or decreased otherwise
  long new_index = index - 1;
  if (event.GetId() == btnRuleDown->GetId()) new_index = index + 1;

  if (new_index < 0 || new_index >= lRules->GetItemCount()) return;

  assert(lRules->GetItemData(index) == reinterpret_cast<wxUIntPtr>(m_rule));
  assert(m_rule == rules[index]);

  Rule* changed = rules[new_index];
  assert(changed);

  int dummy = changed->getNumber();
  changed->setNumber(m_rule->getNumber());
  m_rule->setNumber(dummy);

  if (!repo->saveRule(m_rule) || !repo->saveRule(changed)) return;

  rules[index] = changed;
  rules[new_index] = m_rule;

  {
    Freezer freezer(lRules);
    wxListItem item;

    wxString title = lRules->GetItemText(index, COLUMN_TITLE);
    wxString period = lRules->GetItemText(index, COLUMN_PERIOD);

    item.SetId(index);
    item.SetMask(-1);

    lRules->GetItem(item);
    lRules->DeleteItem(index);

    item.SetId(new_index);
    lRules->InsertItem(item);
    lRules->SetItem(new_index, COLUMN_TITLE, title);
    lRules->SetItem(new_index, COLUMN_PERIOD, period);
  }

  lRules->SetItemState(new_index, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED);

  updateImage();
}

void MainFrame::OnFromChecked(wxCommandEvent& event) {
  dpFrom->Enable(event.IsChecked());
}

void MainFrame::OnTillChecked(wxCommandEvent& event) {
  dpTill->Enable(event.IsChecked());
}

void MainFrame::updateImage(void) {
  if (!m_doctor || rules.empty()) {
    // Clear image
    bmpWeek->SetBitmap(chart.get());
  } else {
    // Fill image with rules
    bmpWeek->SetBitmap(chart.get(rules));
  }
}

void MainFrame::DeptMove( wxCommandEvent& event ) {
  int index = chProfile->GetSelection();
  if (index == wxNOT_FOUND) return;
  
  int new_index = index - 1;
  if (event.GetId() == btnDeptDown->GetId()) new_index = index + 1;
  
  if (new_index < 0 || new_index >= (int)chProfile->GetCount()) return;
  
  Profile *current = static_cast<Profile*>(chProfile->GetClientData(index));
  Profile *other = static_cast<Profile*>(chProfile->GetClientData(new_index));
  assert(current && other);
  
  int dummy = other->getNumber();
  other->setNumber(current->getNumber());
  current->setNumber(dummy);
  
  if (!repo->saveProfile(current) || !repo->saveProfile(other)) return;
  
  wxString title = chProfile->GetString(index);
  chProfile->SetString(index, chProfile->GetString(new_index));
  chProfile->SetString(new_index, title);
  
  chProfile->SetClientData(index, other);
  chProfile->SetClientData(new_index, current);
  
  chProfile->SetSelection(new_index);
}
